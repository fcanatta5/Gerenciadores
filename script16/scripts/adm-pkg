#!/bin/sh
# adm-pkg - minimal rolling package manager (POSIX sh, no bashisms)
# Target: x86_64-linux-musl (but generally portable)
#
# Layout:
#   Build scripts: /usr/adm/packages/<category>/<pkg>/build
#   Optional: patch/  (auto-applied, configurable patchlevel)
#            files/  (overlay copied into DESTDIR after install)
#
# Key guarantees:
#   - Always staged install via DESTDIR
#   - Source cache with checksum validation and refetch on mismatch
#   - Binary package cache (tar.zst preferred, tar.xz fallback)
#   - Dependency resolution with cycle detection (toposort)
#   - Atomic upgrade: apply new, then remove old-only paths
#   - Resume support (ADM_RESUME=1). Clean builds with ADM_RESUME=0
#   - Autodetect build systems: autotools, make, meson, cmake, cargo, go,
#     python (pyproject/setuptools), npm, perl, ruby, scons, waf
#   - Hints: AUTOBUILD_HINT to remove heuristics without hooks

umask 022

###############################################################################
# Defaults (override via /etc/adm-pkg.conf or environment)
###############################################################################
: "${ADM_ROOT:=/}"
: "${ADM_PKGS_DIR:=/usr/adm/packages}"
: "${ADM_DB_DIR:=/var/lib/adm-pkg}"
: "${ADM_CACHE_DIR:=/var/cache/adm-pkg}"
: "${ADM_SRC_CACHE:=$ADM_CACHE_DIR/sources}"
: "${ADM_BIN_CACHE:=$ADM_CACHE_DIR/binpkgs}"
: "${ADM_BUILD_DIR:=$ADM_CACHE_DIR/build}"
: "${ADM_LOG_DIR:=/var/log/adm-pkg}"

: "${ADM_JOBS:=1}"
: "${ADM_FETCH_CMD:=auto}"     # auto|curl|wget
: "${ADM_RESUME:=1}"           # 1=resume enabled, 0=always clean workdir
: "${ADM_STRIP:=1}"            # 1 or 0

: "${ADM_CFLAGS:=-O2 -pipe}"
: "${ADM_CXXFLAGS:=-O2 -pipe}"
: "${ADM_LDFLAGS:=-Wl,-O1}"
: "${ADM_MAKEFLAGS:=}"

: "${ADM_TAR:=tar}"
: "${ADM_ZSTD:=zstd}"
: "${ADM_XZ:=xz}"
: "${ADM_SHA256:=sha256sum}"
: "${ADM_MD5:=md5sum}"
: "${ADM_INSTALL:=install}"
: "${ADM_SED:=sed}"
: "${ADM_AWK:=awk}"
: "${ADM_GREP:=grep}"
: "${ADM_SORT:=sort}"
: "${ADM_FIND:=find}"
: "${ADM_CP:=cp}"
: "${ADM_RM:=rm}"
: "${ADM_MKDIR:=mkdir}"
: "${ADM_TOUCH:=touch}"
: "${ADM_DATE:=date}"
: "${ADM_GIT:=git}"
: "${ADM_TR:=tr}"

: "${ADM_GIT_REPO_DIR:=/usr/adm}"  # optional git repo root for sync

CONFIG_FILE="/etc/adm-pkg.conf"
[ -f "$CONFIG_FILE" ] && . "$CONFIG_FILE"

###############################################################################
# Helpers
###############################################################################
die() { echo "adm-pkg: ERROR: $*" >&2; exit 1; }
msg() { echo "==> $*"; }
now() { "$ADM_DATE" '+%Y-%m-%d %H:%M:%S'; }

ensure_dir() { [ -d "$1" ] || "$ADM_MKDIR" -p "$1" || die "cannot create dir: $1"; }
need_cmd() { command -v "$1" >/dev/null 2>&1 || die "missing required command: $1"; }
have() { command -v "$1" >/dev/null 2>&1; }

# Logging
log_init() {
  ensure_dir "$ADM_LOG_DIR"
  ensure_dir "$ADM_DB_DIR"
  ensure_dir "$ADM_DB_DIR/pkgs"
  ensure_dir "$ADM_CACHE_DIR"
  ensure_dir "$ADM_SRC_CACHE"
  ensure_dir "$ADM_BIN_CACHE"
  ensure_dir "$ADM_BUILD_DIR"
}

log_file_for() { echo "$ADM_LOG_DIR/$1-$2-r$3.log"; }

log() {
  if [ -n "${ADM_CURRENT_LOG:-}" ]; then
    printf '%s %s\n' "$(now)" "$*" | tee -a "$ADM_CURRENT_LOG"
  else
    printf '%s %s\n' "$(now)" "$*"
  fi
}

# Lock (mkdir-based)
with_lock() {
  ensure_dir "$ADM_DB_DIR"
  LOCKDIR="$ADM_DB_DIR/.lock"
  i=0
  while ! "$ADM_MKDIR" "$LOCKDIR" 2>/dev/null; do
    i=$((i+1))
    [ "$i" -gt 200 ] && die "could not acquire lock: $LOCKDIR (stale?)"
    sleep 1
  done
  trap 'rmdir "$LOCKDIR" 2>/dev/null; exit 1' INT TERM HUP
}
unlock() {
  rmdir "$ADM_DB_DIR/.lock" 2>/dev/null || true
  trap - INT TERM HUP
}

###############################################################################
# Package metadata loading
###############################################################################
reset_pkg_vars() {
  PKGDIR=""
  BUILDSCRIPT=""
  PKGNAME=""
  PKGVER=""
  PKGREL="1"
  SECTION=""
  PKGDESC=""
  PKGURL=""
  LICENSE=""
  ARCH="x86_64"

  SOURCES=""
  SUMTYPE="sha256"   # sha256|md5
  SUMS=""

  DEPENDS=""
  BUILD_DEPENDS=""

  AUTOBUILD_HINT=""
  PATCHLEVEL=""
}

pkg_path_from_name() {
  # input: name or category/name
  case "$1" in
    */*) p="$ADM_PKGS_DIR/$1" ;;
    *)   p=$("$ADM_FIND" "$ADM_PKGS_DIR" -mindepth 2 -maxdepth 2 -type d -name "$1" 2>/dev/null \
            | "$ADM_SORT" | "$ADM_AWK" 'NR==1{print; exit}') ;;
  esac
  [ -n "$p" ] && [ -d "$p" ] && [ -f "$p/build" ] || return 1
  echo "$p"
}

load_build_script() {
  reset_pkg_vars
  PKGDIR="$1"
  BUILDSCRIPT="$PKGDIR/build"
  [ -f "$BUILDSCRIPT" ] || die "build script not found: $BUILDSCRIPT"

  # shellcheck disable=SC1090
  . "$BUILDSCRIPT" || die "failed to source build script: $BUILDSCRIPT"

  [ -n "$PKGNAME" ] || die "PKGNAME not set in $BUILDSCRIPT"
  [ -n "$PKGVER" ]  || die "PKGVER not set in $BUILDSCRIPT"
  [ -n "${PKGREL:-}" ] || PKGREL="1"
  [ -n "${SECTION:-}" ] || SECTION="$(basename "$(dirname "$PKGDIR")")"

  # Export for build scripts
  export ADM_ROOT ADM_PKGS_DIR ADM_DB_DIR ADM_CACHE_DIR ADM_SRC_CACHE ADM_BIN_CACHE ADM_BUILD_DIR ADM_LOG_DIR
  export ADM_JOBS ADM_CFLAGS ADM_CXXFLAGS ADM_LDFLAGS ADM_MAKEFLAGS ADM_STRIP ADM_RESUME
  export PKGDIR BUILDSCRIPT PKGNAME PKGVER PKGREL SECTION PKGDESC PKGURL LICENSE ARCH
  export SOURCES SUMTYPE SUMS DEPENDS BUILD_DEPENDS AUTOBUILD_HINT PATCHLEVEL
}

pkg_id() { echo "$PKGNAME-$PKGVER-r$PKGREL"; }

db_pkg_dir() { echo "$ADM_DB_DIR/pkgs/$PKGNAME"; }
db_installed_marker() { echo "$(db_pkg_dir)/installed"; }
db_manifest() { echo "$(db_pkg_dir)/manifest"; }
db_meta() { echo "$(db_pkg_dir)/meta"; }
is_installed() { [ -f "$(db_installed_marker)" ]; }

###############################################################################
# Hints
###############################################################################
: "${AUTOBUILD_HINT:=}"

hint_lines() {
  # Normaliza AUTOBUILD_HINT em 1 token por linha.
  # Aceita tokens com ou sem ":" (ex: "cargo" e "cargo-bin:foo")
  printf '%s\n' "${AUTOBUILD_HINT:-}" \
    | "$ADM_SED" 's/[[:space:]]\+/ /g; s/^ *//; s/ *$//' \
    | "$ADM_TR" ' ' '\n' \
    | "$ADM_SED" '/^[[:space:]]*$/d'
}

hint_get() {
  # Uso:
  #   hint_get "system:" -> retorna o valor após "system:"
  #   hint_get "cargo-bin:" -> retorna foo
  #   hint_get "cargo" -> retorna "1" se existir token "cargo" (sem ":")
  pfx="$1"
  hint_lines | while IFS= read -r h; do
    case "$pfx" in
      *:)
        case "$h" in
          "$pfx"*) printf '%s\n' "${h#"$pfx"}"; return 0 ;;
        esac
        ;;
      *)
        case "$h" in
          "$pfx") printf '%s\n' "1"; return 0 ;;
        esac
        ;;
    esac
  done
  printf '%s\n' ""
}

hint_has() {
  # Retorna 0 se existe, 1 se não existe (estilo "test")
  # Aceita prefixos com ":" e flags sem ":"
  pfx="$1"
  v="$(hint_get "$pfx")"
  [ -n "$v" ]
}

###############################################################################
# Workdir / state / cleaning
###############################################################################
state_file() { echo "$WORKDIR/.state"; }
state_set() { echo "$1" >"$(state_file)"; }
state_get() { [ -f "$(state_file)" ] && cat "$(state_file)" || echo "none"; }

prepare_workdir() {
  ensure_dir "$ADM_BUILD_DIR"
  WORKDIR="$ADM_BUILD_DIR/$PKGNAME-$PKGVER-r$PKGREL"
  DESTDIR="$WORKDIR/destdir"
  export WORKDIR DESTDIR

  if [ "${ADM_RESUME:-1}" -eq 0 ]; then
    [ -d "$WORKDIR" ] && "$ADM_RM" -rf "$WORKDIR"
  fi
  ensure_dir "$WORKDIR"

  # Always clean DESTDIR
  [ -d "$DESTDIR" ] && "$ADM_RM" -rf "$DESTDIR"
  ensure_dir "$DESTDIR"
}

###############################################################################
# Fetching sources with cache + checksum validation
###############################################################################
pick_fetch_cmd() {
  case "$ADM_FETCH_CMD" in
    curl) need_cmd curl; echo "curl -L --fail -o" ;;
    wget) need_cmd wget; echo "wget -O" ;;
    auto)
      if have curl; then echo "curl -L --fail -o"
      elif have wget; then echo "wget -O"
      else die "need curl or wget for fetching"
      fi
      ;;
    *) die "invalid ADM_FETCH_CMD=$ADM_FETCH_CMD" ;;
  esac
}

checksum_file() {
  t="$1"; f="$2"
  case "$t" in
    sha256) need_cmd "$ADM_SHA256"; "$ADM_SHA256" "$f" | "$ADM_AWK" '{print $1}' ;;
    md5)    need_cmd "$ADM_MD5";    "$ADM_MD5" "$f"    | "$ADM_AWK" '{print $1}' ;;
    *) die "invalid SUMTYPE=$t (use sha256 or md5)" ;;
  esac
}

default_fetch() {
  ensure_dir "$ADM_SRC_CACHE"
  fetchcmd="$(pick_fetch_cmd)"

  src_list="$WORKDIR/.sources"
  sum_list="$WORKDIR/.sums"
  printf '%s\n' "$SOURCES" | "$ADM_SED" '/^[[:space:]]*$/d' >"$src_list"
  printf '%s\n' "$SUMS"    | "$ADM_SED" '/^[[:space:]]*$/d' >"$sum_list"

  src_count=$("$ADM_AWK" 'END{print NR+0}' "$src_list")
  sum_count=$("$ADM_AWK" 'END{print NR+0}' "$sum_list")
  [ "$src_count" -eq "$sum_count" ] || die "SOURCES count ($src_count) != SUMS count ($sum_count) in $BUILDSCRIPT"

  i=1
  while [ "$i" -le "$src_count" ]; do
    src=$("$ADM_AWK" "NR==$i{print; exit}" "$src_list")
    exp=$("$ADM_AWK" "NR==$i{print; exit}" "$sum_list")

    case "$src" in
      *"::"*)
        name=$(printf '%s' "$src" | "$ADM_AWK" -F"::" '{print $1}')
        url=$(printf '%s' "$src" | "$ADM_AWK" -F"::" '{print $2}')
        ;;
      *)
        name=""
        url="$src"
        ;;
    esac

    base=$(basename "$url")
    [ -n "$name" ] && base="$name"
    cached="$ADM_SRC_CACHE/$base"

    fetch_one() {
      if printf '%s' "$url" | "$ADM_GREP" -qE '^(https?://)'; then
        log "fetch: $url -> $cached"
        # shellcheck disable=SC2086
        $fetchcmd "$cached.tmp" "$url" || return 1
        mv "$cached.tmp" "$cached" || return 1
      else
        if [ -f "$PKGDIR/$url" ]; then
          log "copy local source: $PKGDIR/$url -> $cached"
          "$ADM_CP" -f "$PKGDIR/$url" "$cached" || return 1
        elif [ -f "$url" ]; then
          log "copy local source: $url -> $cached"
          "$ADM_CP" -f "$url" "$cached" || return 1
        else
          die "source not found: $url"
        fi
      fi
      return 0
    }

    if [ -f "$cached" ]; then
      got="$(checksum_file "$SUMTYPE" "$cached" || true)"
      if [ "$got" != "$exp" ]; then
        log "checksum mismatch for cached $base; deleting and refetching"
        "$ADM_RM" -f "$cached"
      fi
    fi

    if [ ! -f "$cached" ]; then
      fetch_one || die "failed to fetch source: $url"
      got="$(checksum_file "$SUMTYPE" "$cached")"
      [ "$got" = "$exp" ] || { "$ADM_RM" -f "$cached"; die "checksum mismatch after download: $base"; }
    fi

    "$ADM_CP" -f "$cached" "$WORKDIR/$base" || die "cannot stage source: $base"
    i=$((i+1))
  done
}

###############################################################################
# Unpack (supports multiple archives + srcdir/unpack hints)
###############################################################################
is_archive() {
  case "$1" in
    *.tar|*.tar.gz|*.tgz|*.tar.bz2|*.tbz2|*.tar.xz|*.txz|*.tar.zst) return 0 ;;
  esac
  return 1
}

unpack_one() {
  f="$1"
  [ -f "$f" ] || return 1
  case "$f" in
    *.tar.zst)
      need_cmd "$ADM_ZSTD"
      "$ADM_ZSTD" -dc "$f" | (cd "$WORKSRCROOT" && "$ADM_TAR" -xpf -) || return 1
      ;;
    *.tar.xz|*.txz)
      need_cmd "$ADM_XZ"
      "$ADM_XZ" -dc "$f" | (cd "$WORKSRCROOT" && "$ADM_TAR" -xpf -) || return 1
      ;;
    *.tar.gz|*.tgz)
      need_cmd gzip
      gzip -dc "$f" | (cd "$WORKSRCROOT" && "$ADM_TAR" -xpf -) || return 1
      ;;
    *.tar.bz2|*.tbz2)
      need_cmd bzip2
      bzip2 -dc "$f" | (cd "$WORKSRCROOT" && "$ADM_TAR" -xpf -) || return 1
      ;;
    *.tar)
      (cd "$WORKSRCROOT" && "$ADM_TAR" -xpf "$f") || return 1
      ;;
    *) return 1 ;;
  esac
  return 0
}

is_archive() {
  case "$1" in
    *.tar|*.tar.gz|*.tgz|*.tar.bz2|*.tbz2|*.tar.xz|*.txz|*.tar.zst) return 0 ;;
  esac
  return 1
}

unpack_one() {
  f="$1"
  [ -f "$f" ] || return 1

  case "$f" in
    *.tar.zst)
      command -v "$ADM_ZSTD" >/dev/null 2>&1 || die "need zstd to unpack: $f"
      "$ADM_ZSTD" -dc "$f" | (cd "$WORKSRCROOT" && "$ADM_TAR" -xpf -) || return 1
      ;;
    *.tar.xz|*.txz)
      command -v "$ADM_XZ" >/dev/null 2>&1 || die "need xz to unpack: $f"
      "$ADM_XZ" -dc "$f" | (cd "$WORKSRCROOT" && "$ADM_TAR" -xpf -) || return 1
      ;;
    *.tar.gz|*.tgz)
      command -v gzip >/dev/null 2>&1 || die "need gzip to unpack: $f"
      gzip -dc "$f" | (cd "$WORKSRCROOT" && "$ADM_TAR" -xpf -) || return 1
      ;;
    *.tar.bz2|*.tbz2)
      command -v bzip2 >/dev/null 2>&1 || die "need bzip2 to unpack: $f"
      bzip2 -dc "$f" | (cd "$WORKSRCROOT" && "$ADM_TAR" -xpf -) || return 1
      ;;
    *.tar)
      (cd "$WORKSRCROOT" && "$ADM_TAR" -xpf "$f") || return 1
      ;;
    *) return 1 ;;
  esac
  return 0
}

default_unpack() {
  WORKSRCROOT="$WORKDIR/srcroot"
  ensure_dir "$WORKSRCROOT"
  export WORKSRCROOT

  # Se o pacote fornecer hint "unpack:a.tar.xz,b.tar.gz", usa essa ordem
  ulist="$(hint_get "unpack:")"
  if [ -n "$ulist" ]; then
    oldIFS=$IFS; IFS=,
    for n in $ulist; do
      IFS=$oldIFS
      n=$(printf '%s' "$n" | "$ADM_SED" 's/^ *//; s/ *$//')
      [ -n "$n" ] || continue
      log "unpack (hint): $n"
      unpack_one "$WORKDIR/$n" || die "unpack failed: $n"
      IFS=,
    done
    IFS=$oldIFS
  else
    # Caso padrão: extrai todos os arquivos-archive em WORKDIR
    "$ADM_FIND" "$WORKDIR" -maxdepth 1 -type f 2>/dev/null | "$ADM_SORT" | while IFS= read -r f; do
      if is_archive "$f"; then
        log "unpack: $(basename "$f")"
        unpack_one "$f" || die "unpack failed: $(basename "$f")"
      fi
    done
  fi

  # Determina WORKSRC
  sdh="$(hint_get "srcdir:")"
  if [ -n "$sdh" ]; then
    WORKSRC="$WORKSRCROOT/$sdh"
    [ -d "$WORKSRC" ] || die "srcdir hint not found: $sdh"
  else
    topcount=$("$ADM_FIND" "$WORKSRCROOT" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | "$ADM_AWK" 'END{print NR+0}')
    if [ "$topcount" -eq 1 ]; then
      WORKSRC=$("$ADM_FIND" "$WORKSRCROOT" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | "$ADM_AWK" 'NR==1{print; exit}')
    else
      WORKSRC="$WORKSRCROOT"
    fi
  fi

  export WORKSRC
}

###############################################################################
# Patch + files overlay
###############################################################################
default_patchlevel() {
  pl="$(hint_get "patchlevel:")"
  if [ -z "$pl" ]; then
    [ -n "${PATCHLEVEL:-}" ] && pl="$PATCHLEVEL" || pl="1"
  fi
  printf '%s\n' "$pl"
}

apply_patches() {
  patchdir="$PKGDIR/patch"
  [ -d "$patchdir" ] || return 0

  command -v patch >/dev/null 2>&1 || die "missing required command: patch"
  pl="$(default_patchlevel)"

  "$ADM_FIND" "$patchdir" -type f 2>/dev/null | "$ADM_SORT" | while IFS= read -r p; do
    log "apply patch: $(basename "$p") (-p$pl)"
    (cd "$WORKSRC" && patch -p"$pl" <"$p") || die "patch failed: $p"
  done
}

copy_files_overlay() {
  filesdir="$PKGDIR/files"
  [ -d "$filesdir" ] || return 0
  log "overlay files/: copying into DESTDIR"
  # Preserve modes/ownership where possible (-p). BusyBox tar supports -p.
  (cd "$filesdir" && "$ADM_TAR" -cpf - .) | (cd "$DESTDIR" && "$ADM_TAR" -xpf -) || die "files/ overlay failed"
}

###############################################################################
# Dependency resolution: closure + toposort (cycle detection)
###############################################################################
dep_edges_for_pkg() {
  pd="$(pkg_path_from_name "$1" || true)"
  [ -n "$pd" ] || die "cannot locate package: $1"
  load_build_script "$pd"

  all_deps=$(printf '%s\n%s\n' "$DEPENDS" "$BUILD_DEPENDS" | "$ADM_SED" '/^[[:space:]]*$/d')
  printf '%s\n' "$all_deps" | "$ADM_SED" 's/[[:space:]]\+/ /g; s/^ *//; s/ *$//' \
    | "$ADM_TR" ' ' '\n' | "$ADM_SED" '/^[[:space:]]*$/d' \
    | while IFS= read -r d; do printf '%s %s\n' "$1" "$d"; done
}

toposort() {
  inlist="$1"
  tmp="$WORKDIR/.topo"
  edges="$tmp.edges"
  nodes="$tmp.nodes"
  indeg="$tmp.indeg"
  queue="$tmp.queue"
  out="$tmp.out"
  seen="$tmp.seen"
  frontier="$tmp.frontier"

  : >"$edges"; : >"$nodes"; : >"$indeg"; : >"$queue"; : >"$out"; : >"$seen"

  "$ADM_CP" -f "$inlist" "$frontier"

  while :; do
    "$ADM_SED" '/^[[:space:]]*$/d' "$frontier" | "$ADM_SORT" -u >"$frontier.u"
    mv "$frontier.u" "$frontier"
    [ -s "$frontier" ] || break

    : >"$tmp.next"
    while IFS= read -r p; do
      "$ADM_GREP" -qx "$p" "$seen" 2>/dev/null && continue
      printf '%s\n' "$p" >>"$seen"
      printf '%s\n' "$p" >>"$nodes"
      dep_edges_for_pkg "$p" >>"$edges"
      dep_edges_for_pkg "$p" | "$ADM_AWK" '{print $2}' >>"$tmp.next"
    done <"$frontier"
    mv "$tmp.next" "$frontier"
  done

  "$ADM_SORT" -u "$nodes" >"$nodes.u" && mv "$nodes.u" "$nodes"

  while IFS= read -r n; do
    c=$("$ADM_GREP" -E "^[^ ]+ $n$" "$edges" 2>/dev/null | "$ADM_AWK" 'END{print NR+0}')
    printf '%s %s\n' "$n" "$c" >>"$indeg"
  done <"$nodes"

  "$ADM_AWK" '$2==0{print $1}' "$indeg" >"$queue"

  processed=0
  total=$("$ADM_AWK" 'END{print NR+0}' "$nodes")

  while [ -s "$queue" ]; do
    n=$("$ADM_AWK" 'NR==1{print $1; exit}' "$queue")
    "$ADM_AWK" 'NR>1{print}' "$queue" >"$queue.tmp" && mv "$queue.tmp" "$queue"
    printf '%s\n' "$n" >>"$out"
    processed=$((processed+1))

    "$ADM_GREP" -E "^[^ ]+ $n$" "$edges" 2>/dev/null | "$ADM_AWK" '{print $1}' | while IFS= read -r a; do
      cur=$("$ADM_AWK" -v k="$a" '$1==k{print $2; exit}' "$indeg")
      new=$((cur-1))
      "$ADM_AWK" -v k="$a" -v v="$new" '{if($1==k){print $1, v}else{print}}' "$indeg" >"$indeg.tmp" && mv "$indeg.tmp" "$indeg"
      if [ "$new" -eq 0 ]; then printf '%s\n' "$a" >>"$queue"; fi
    done
  done

  if [ "$processed" -ne "$total" ]; then
    log "dependency cycle detected. Remaining nodes:"
    "$ADM_AWK" '$2>0{print " - "$1}' "$indeg" >&2
    die "cannot resolve dependency order due to cycle"
  fi

  cat "$out"
}

###############################################################################
# Hooks and phases (FIXED: fetch is a real phase now)
###############################################################################
run_hook() {
  h="$1"
  fn="hook_$h"
  if command -v "$fn" >/dev/null 2>&1; then
    log "hook: $fn"
    "$fn" || die "hook failed: $fn"
  fi
}

call_phase() {
  ph="$1"
  fn="pkg_$ph"

  run_hook "pre_$ph"

  if command -v "$fn" >/dev/null 2>&1; then
    log "phase: $fn"
    "$fn" || die "phase failed: $fn"
  else
    case "$ph" in
      fetch)   default_fetch ;;
      unpack)  default_unpack ;;
      prepare) apply_patches ;;
      build)   default_build ;;
      check)   default_check ;;
      install) default_install ;;
      *) die "unknown phase: $ph" ;;
    esac
  fi

  run_hook "post_$ph"
}

###############################################################################
# Autodetection + default build/install (extended)
###############################################################################
pick_ninja() { have ninja && echo ninja && return 0; have samu && echo samu && return 0; echo ""; }

srcdir() { [ -n "${WORKSRC:-}" ] && [ -d "$WORKSRC" ] && echo "$WORKSRC" || echo "$WORKDIR"; }

detect_build_system() {
  d="$(srcdir)"

  forced="$(hint_get "system:")"
  [ -n "$forced" ] && { echo "$forced"; return 0; }

  # hint shorthand
  [ -n "$(hint_get "cargo")" ] && { echo "cargo"; return 0; }
  [ -n "$(hint_get "go")" ] && { echo "go"; return 0; }
  [ -n "$(hint_get "python")" ] && { echo "python"; return 0; }
  [ -n "$(hint_get "npm")" ] && { echo "npm"; return 0; }
  [ -n "$(hint_get "perl")" ] && { echo "perl"; return 0; }
  [ -n "$(hint_get "ruby")" ] && { echo "ruby"; return 0; }
  [ -n "$(hint_get "scons")" ] && { echo "scons"; return 0; }
  [ -n "$(hint_get "waf")" ] && { echo "waf"; return 0; }

  [ -x "$d/waf" ] || [ -f "$d/wscript" ] && { echo "waf"; return 0; }
  [ -f "$d/SConstruct" ] || [ -f "$d/SConscript" ] && { echo "scons"; return 0; }
  [ -f "$d/pyproject.toml" ] || [ -f "$d/setup.py" ] || [ -f "$d/setup.cfg" ] && { echo "python"; return 0; }
  [ -f "$d/package.json" ] && { echo "npm"; return 0; }
  [ -f "$d/Makefile.PL" ] || [ -f "$d/Build.PL" ] && { echo "perl"; return 0; }
  ls "$d"/*.gemspec >/dev/null 2>&1 || [ -f "$d/Rakefile" ] || [ -f "$d/Gemfile" ] && { echo "ruby"; return 0; }
  [ -f "$d/Cargo.toml" ] && { echo "cargo"; return 0; }
  [ -f "$d/go.mod" ] || ls "$d"/*.go >/dev/null 2>&1 && { echo "go"; return 0; }
  [ -f "$d/meson.build" ] && { echo "meson"; return 0; }
  [ -f "$d/CMakeLists.txt" ] && { echo "cmake"; return 0; }
  [ -x "$d/configure" ] && { echo "autotools"; return 0; }
  [ -f "$d/configure.ac" ] || [ -f "$d/configure.in" ] || [ -f "$d/Makefile.am" ] && { echo "autotools_bootstrap"; return 0; }
  [ -f "$d/Makefile" ] || [ -f "$d/makefile" ] || [ -f "$d/GNUmakefile" ] && { echo "make"; return 0; }

  echo "unknown"
}

export_toolchain_env() {
  export CC="${CC:-cc}"
  export CXX="${CXX:-c++}"
  export AR="${AR:-ar}"
  export RANLIB="${RANLIB:-ranlib}"
  export STRIP="${STRIP:-strip}"
  export CFLAGS="${CFLAGS:-$ADM_CFLAGS}"
  export CXXFLAGS="${CXXFLAGS:-$ADM_CXXFLAGS}"
  export LDFLAGS="${LDFLAGS:-$ADM_LDFLAGS}"
  export MAKEFLAGS="${MAKEFLAGS:-$ADM_MAKEFLAGS}"
}

default_check() { :; }

default_build() {
  d="$(srcdir)"
  cd "$d" || die "cannot cd source dir: $d"
  export_toolchain_env

  sys="$(detect_build_system)"
  log "autodetect build system: $sys"

  case "$sys" in
    autotools_bootstrap)
      need_cmd autoreconf
      log "build: autoreconf -fi"
      autoreconf -fi || die "autoreconf failed"
      log "build: ./configure"
      ./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var || die "configure failed"
      log "build: make"
      make -j"$ADM_JOBS" || die "make failed"
      ;;

    autotools)
      log "build: ./configure"
      ./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var || die "configure failed"
      log "build: make"
      make -j"$ADM_JOBS" || die "make failed"
      ;;

    make)
      log "build: make"
      make -j"$ADM_JOBS" || die "make failed"
      ;;

    meson)
      need_cmd meson
      n="$(pick_ninja)"
      [ -n "$n" ] || die "need ninja or samu for meson"
      b="$WORKDIR/.build-meson"
      ensure_dir "$b"
      log "build: meson setup"
      (cd "$b" && meson setup "$d" --prefix=/usr --buildtype=release) || die "meson setup failed"
      log "build: meson compile"
      (cd "$b" && meson compile -j "$ADM_JOBS") || die "meson compile failed"
      ;;

    cmake)
      need_cmd cmake
      n="$(pick_ninja)"
      b="$WORKDIR/.build-cmake"
      ensure_dir "$b"
      gen="Unix Makefiles"
      [ -n "$n" ] && gen="Ninja"
      log "build: cmake configure ($gen)"
      (cd "$b" && cmake -G "$gen" -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_BUILD_TYPE=Release "$d") || die "cmake configure failed"
      log "build: cmake build"
      (cd "$b" && cmake --build . -- -j "$ADM_JOBS") || die "cmake build failed"
      ;;

    cargo)
      need_cmd cargo
      log "build: cargo build --release"
      cargo build --release || die "cargo build failed"
      ;;

    go)
      need_cmd go
      out="$WORKDIR/.go-out"
      ensure_dir "$out"
      log "build: go build"
      if [ -d "$d/cmd" ]; then
        for c in "$d"/cmd/*; do
          [ -d "$c" ] || continue
          name=$(basename "$c")
          (cd "$c" && go build -trimpath -ldflags="-s -w" -o "$out/$name") || die "go build failed: cmd/$name"
        done
      else
        want="$(hint_get "go-bin:")"
        [ -z "$want" ] && want="$PKGNAME"
        go build -trimpath -ldflags="-s -w" -o "$out/$want" . || die "go build failed"
      fi
      ;;

    python)
      need_cmd python3
      log "build: python wheel"
      if python3 -c "import build" >/dev/null 2>&1; then
        python3 -m build --wheel --no-isolation || die "python build failed"
      else
        need_cmd pip3
        ensure_dir "$WORKDIR/.pywheel"
        pip3 wheel --no-deps --no-build-isolation -w "$WORKDIR/.pywheel" . || die "pip wheel failed"
      fi
      ;;

    npm)
      need_cmd npm
      log "build: npm install/ci"
      if [ -f package-lock.json ]; then npm ci || die "npm ci failed"
      else npm install || die "npm install failed"
      fi
      script="$(hint_get "npm-build:")"
      if [ -n "$script" ]; then
        log "build: npm run $script"
        npm run "$script" || die "npm run failed: $script"
      else
        if have node; then
          node -e "const p=require('./package.json');process.exit(p.scripts&&p.scripts.build?0:1)" >/dev/null 2>&1 && \
            { log "build: npm run build"; npm run build || die "npm run build failed"; }
        fi
      fi
      ;;

    perl)
      need_cmd perl
      if [ -f "Build.PL" ]; then
        log "build: perl Build.PL"
        perl Build.PL || die "perl Build.PL failed"
        log "build: ./Build"
        ./Build || die "perl Build failed"
      else
        log "build: perl Makefile.PL"
        perl Makefile.PL PREFIX=/usr || die "perl Makefile.PL failed"
        log "build: make"
        make -j"$ADM_JOBS" || die "perl make failed"
      fi
      ;;

    ruby)
      need_cmd ruby
      if [ -f "Rakefile" ] && have rake; then
        task="$(hint_get "rake:")"; [ -z "$task" ] && task="build"
        log "build: rake $task (best-effort)"
        rake -T 2>/dev/null | "$ADM_GREP" -qE "(^|:)${task}\b" && rake "$task" || true
      fi
      if ls ./*.gemspec >/dev/null 2>&1 && have gem; then
        spec=$(ls ./*.gemspec 2>/dev/null | "$ADM_AWK" 'NR==1{print;exit}')
        log "build: gem build $spec"
        gem build "$spec" || die "gem build failed"
      fi
      ;;

    scons)
      need_cmd scons
      log "build: scons"
      scons -j"$ADM_JOBS" || die "scons build failed"
      ;;

    waf)
      sub="$(hint_get "waf-subdir:")"
      [ -n "$sub" ] && cd "$d/$sub" || true
      wafcmd="./waf"; [ -x "./waf" ] || wafcmd="waf"
      need_cmd "${wafcmd#./}"
      log "build: waf configure"
      "$wafcmd" configure --prefix=/usr || die "waf configure failed"
      log "build: waf build"
      "$wafcmd" build -j"$ADM_JOBS" || die "waf build failed"
      ;;

    *)
      die "unknown build system; define pkg_build/pkg_install or set AUTOBUILD_HINT system:<name>"
      ;;
  esac
}

copy_tree() { (cd "$1" && "$ADM_TAR" -cpf - .) | (cd "$2" && "$ADM_TAR" -xpf -) || return 1; }

default_install() {
  d="$(srcdir)"
  sys="$(detect_build_system)"
  log "autodetect install system: $sys"

  case "$sys" in
    autotools_bootstrap|autotools|make)
      cd "$d" || die "cannot cd source dir: $d"
      log "install: make DESTDIR=... install"
      make DESTDIR="$DESTDIR" install || die "make install failed"
      ;;

    meson)
      b="$WORKDIR/.build-meson"
      [ -d "$b" ] || die "meson build dir missing"
      log "install: meson install --destdir"
      (cd "$b" && meson install --destdir "$DESTDIR") || die "meson install failed"
      ;;

    cmake)
      b="$WORKDIR/.build-cmake"
      [ -d "$b" ] || die "cmake build dir missing"
      log "install: cmake --install with DESTDIR"
      (cd "$b" && DESTDIR="$DESTDIR" cmake --install .) || die "cmake install failed"
      ;;

    cargo)
      cd "$d" || die "cannot cd source dir: $d"
      bindir="$DESTDIR/usr/bin"
      ensure_dir "$bindir"
      td="$d/target/release"
      [ -d "$td" ] || die "cargo target/release not found"
      want="$(hint_get "cargo-bin:")"
      if [ -n "$want" ]; then
        [ -x "$td/$want" ] || die "cargo-bin not found/executable: $want"
        log "install: cargo-bin $want -> /usr/bin"
        "$ADM_INSTALL" -m 0755 "$td/$want" "$bindir/$want" || die "install failed: $want"
      else
        log "install: cargo bins -> /usr/bin (heuristic)"
        for f in "$td"/*; do
          [ -f "$f" ] || continue
          [ -x "$f" ] || continue
          case "$(basename "$f")" in *.d|*.rlib|*.so|*.a) continue ;; esac
          "$ADM_INSTALL" -m 0755 "$f" "$bindir/$(basename "$f")" || die "install failed: $(basename "$f")"
        done
      fi
      ;;

    go)
      bindir="$DESTDIR/usr/bin"
      ensure_dir "$bindir"
      out="$WORKDIR/.go-out"
      [ -d "$out" ] || die "go build output not found"
      want="$(hint_get "go-bin:")"
      if [ -n "$want" ]; then
        [ -f "$out/$want" ] || die "go-bin not found: $want"
        log "install: go-bin $want -> /usr/bin"
        "$ADM_INSTALL" -m 0755 "$out/$want" "$bindir/$want" || die "install failed: $want"
      else
        log "install: go binaries -> /usr/bin"
        for f in "$out"/*; do
          [ -f "$f" ] || continue
          "$ADM_INSTALL" -m 0755 "$f" "$bindir/$(basename "$f")" || die "install failed: $(basename "$f")"
        done
      fi
      ;;

    python)
      need_cmd python3; need_cmd pip3
      cd "$d" || die "cannot cd source dir: $d"
      whl=""
      [ -d "$d/dist" ] && whl=$(ls "$d"/dist/*.whl 2>/dev/null | "$ADM_AWK" 'NR==1{print;exit}')
      if [ -z "$whl" ] && [ -d "$WORKDIR/.pywheel" ]; then
        whl=$(ls "$WORKDIR"/.pywheel/*.whl 2>/dev/null | "$ADM_AWK" 'NR==1{print;exit}')
      fi
      [ -n "$whl" ] || die "no wheel found (python build did not produce .whl)"
      log "install: python wheel -> DESTDIR"
      pip3 install --no-deps --no-compile --no-warn-script-location --prefix=/usr --root="$DESTDIR" "$whl" || die "pip install wheel failed"
      ;;

    npm)
      need_cmd npm
      cd "$d" || die "cannot cd source dir: $d"
      sharedir="$DESTDIR/usr/share/$PKGNAME"
      ensure_dir "$sharedir"
      outdir="$(hint_get "npm-out:")"; [ -z "$outdir" ] && outdir="dist"
      if [ -d "$d/$outdir" ]; then
        log "install: npm output $outdir -> /usr/share/$PKGNAME"
        copy_tree "$d/$outdir" "$sharedir" || die "npm output copy failed"
      else
        log "install: npm no dist found; installing minimal package.json"
        [ -f "$d/package.json" ] && "$ADM_INSTALL" -m 0644 "$d/package.json" "$sharedir/package.json" || true
      fi
      bspec="$(hint_get "npm-bin:")"
      if [ -n "$bspec" ]; then
        name=$(printf '%s' "$bspec" | "$ADM_AWK" -F: '{print $1}')
        entry=$(printf '%s' "$bspec" | "$ADM_AWK" -F: '{print $2}')
        bindir="$DESTDIR/usr/bin"
        ensure_dir "$bindir"
        log "install: npm wrapper $name -> /usr/bin"
        cat >"$bindir/$name" <<EOF
#!/bin/sh
exec node /usr/share/$PKGNAME/$entry "\$@"
EOF
        chmod 0755 "$bindir/$name" || die "chmod failed"
      fi
      ;;

    perl)
      need_cmd perl
      cd "$d" || die "cannot cd source dir: $d"
      if [ -f "Build.PL" ]; then
        log "install: ./Build install --destdir"
        ./Build install --destdir "$DESTDIR" || die "perl Build install failed"
      else
        log "install: make DESTDIR install"
        make DESTDIR="$DESTDIR" install || die "perl make install failed"
      fi
      ;;

    ruby)
      need_cmd ruby
      cd "$d" || die "cannot cd source dir: $d"
      if ls ./*.gem >/dev/null 2>&1 && have gem; then
        gemfile=$(ls ./*.gem 2>/dev/null | "$ADM_AWK" 'NR==1{print;exit}')
        vdir="$DESTDIR/usr/lib/ruby/gems"
        ensure_dir "$vdir"
        log "install: gem unpack -> $vdir"
        (cd "$vdir" && gem unpack "$d/$gemfile") || die "gem unpack failed"
      elif ls ./*.gemspec >/dev/null 2>&1 && have gem; then
        spec=$(ls ./*.gemspec 2>/dev/null | "$ADM_AWK" 'NR==1{print;exit}')
        gem build "$spec" || die "gem build failed"
        gemfile=$(ls ./*.gem 2>/dev/null | "$ADM_AWK" 'NR==1{print;exit}')
        vdir="$DESTDIR/usr/lib/ruby/gems"
        ensure_dir "$vdir"
        log "install: gem unpack -> $vdir"
        (cd "$vdir" && gem unpack "$d/$gemfile") || die "gem unpack failed"
      elif [ -f "Rakefile" ] && have rake; then
        log "install: rake install (best-effort)"
        rake install DESTDIR="$DESTDIR" PREFIX=/usr 2>/dev/null || die "rake install failed"
      else
        die "ruby install unknown; use pkg_install or provide gemspec"
      fi
      ;;

    scons)
      need_cmd scons
      cd "$d" || die "cannot cd source dir: $d"
      log "install: scons DESTDIR install"
      scons DESTDIR="$DESTDIR" PREFIX=/usr install || die "scons install failed"
      ;;

    waf)
      sub="$(hint_get "waf-subdir:")"
      [ -n "$sub" ] && cd "$d/$sub" || true
      wafcmd="./waf"; [ -x "./waf" ] || wafcmd="waf"
      need_cmd "${wafcmd#./}"
      log "install: waf install --destdir"
      "$wafcmd" install --destdir="$DESTDIR" || die "waf install failed"
      ;;

    *)
      die "unknown install system; define pkg_install or set AUTOBUILD_HINT system:<name>"
      ;;
  esac

  copy_files_overlay
}

###############################################################################
# Packaging: manifest, strip, tar.zst (fallback xz)
###############################################################################
write_meta() {
  ensure_dir "$(db_pkg_dir)"
  {
    echo "PKGNAME=$PKGNAME"
    echo "PKGVER=$PKGVER"
    echo "PKGREL=$PKGREL"
    echo "SECTION=$SECTION"
    echo "PKGDESC=$PKGDESC"
    echo "PKGURL=$PKGURL"
    echo "LICENSE=$LICENSE"
    echo "ARCH=$ARCH"
    echo "DEPENDS=$(printf '%s' "$DEPENDS" | "$ADM_SED" 's/[[:space:]]\+/ /g; s/^ *//; s/ *$//')"
    echo "BUILD_DEPENDS=$(printf '%s' "$BUILD_DEPENDS" | "$ADM_SED" 's/[[:space:]]\+/ /g; s/^ *//; s/ *$//')"
    echo "BUILDTIME=$(now)"
  } >"$(db_meta)"
}

make_manifest() {
  (cd "$DESTDIR" && "$ADM_FIND" . -mindepth 1 -print | "$ADM_SED" 's#^\./##') | "$ADM_SORT" >"$WORKDIR/manifest"
}

strip_binaries() {
  [ "${ADM_STRIP:-1}" -eq 1 ] || return 0
  have strip || return 0
  (cd "$DESTDIR" && "$ADM_FIND" . -type f 2>/dev/null) | while IFS= read -r f; do
    case "$f" in
      */bin/*|*/sbin/*|*/lib/*.so*|*/libexec/*)
        strip --strip-unneeded "$DESTDIR/$f" 2>/dev/null || true
        ;;
    esac
  done
}

pkg_artifact_path_zst() { echo "$ADM_BIN_CACHE/$(pkg_id).tar.zst"; }
pkg_artifact_path_xz()  { echo "$ADM_BIN_CACHE/$(pkg_id).tar.xz"; }

pack_destdir() {
  ensure_dir "$ADM_BIN_CACHE"
  zst="$(pkg_artifact_path_zst)"
  xz="$(pkg_artifact_path_xz)"

  make_manifest
  strip_binaries

  if have "$ADM_ZSTD"; then
    log "pack: $(basename "$zst")"
    (cd "$DESTDIR" && "$ADM_TAR" -cf - .) | "$ADM_ZSTD" -q -T0 -19 -o "$zst.tmp" || die "zstd packaging failed"
    mv "$zst.tmp" "$zst" || die "cannot move artifact"
    [ -f "$xz" ] && "$ADM_RM" -f "$xz" || true
  else
    need_cmd "$ADM_XZ"
    log "pack: $(basename "$xz") (fallback)"
    (cd "$DESTDIR" && "$ADM_TAR" -cf - .) | "$ADM_XZ" -c -T0 -9 >"$xz.tmp" || die "xz packaging failed"
    mv "$xz.tmp" "$xz" || die "cannot move artifact"
    [ -f "$zst" ] && "$ADM_RM" -f "$zst" || true
  fi
}

artifact_for_loaded_pkg() {
  z="$(pkg_artifact_path_zst)"; x="$(pkg_artifact_path_xz)"
  [ -f "$z" ] && { echo "$z"; return 0; }
  [ -f "$x" ] && { echo "$x"; return 0; }
  return 1
}

###############################################################################
# Install/upgrade/uninstall using manifest
###############################################################################
remove_paths_from_manifest() {
  mf="$1"
  [ -f "$mf" ] || return 0

  log "uninstall: removing files"
  while IFS= read -r p; do
    [ -n "$p" ] || continue
    case "$p" in ""|"/"|".") continue ;; esac
    if [ -f "$ADM_ROOT/$p" ] || [ -L "$ADM_ROOT/$p" ]; then
      "$ADM_RM" -f "$ADM_ROOT/$p" 2>/dev/null || true
    fi
  done <"$mf"

  log "uninstall: pruning empty directories"
  "$ADM_AWK" -F/ '{print NF, $0}' "$mf" | "$ADM_SORT" -rn | "$ADM_AWK" '{ $1=""; sub(/^ /,""); print }' \
    | while IFS= read -r p; do
      [ -d "$ADM_ROOT/$p" ] && rmdir "$ADM_ROOT/$p" 2>/dev/null || true
    done
}

install_pkg_loaded() {
  a="$(artifact_for_loaded_pkg || true)"
  if [ -z "$a" ]; then
    build_pkg "$PKGDIR"
    a="$(artifact_for_loaded_pkg)" || die "build completed but no artifact found"
  fi

  staging="$ADM_BUILD_DIR/.stage-$PKGNAME-$$"
  ensure_dir "$staging"
  log "install: staging extract -> $staging"

  case "$a" in
    *.tar.zst)
      need_cmd "$ADM_ZSTD"
      "$ADM_ZSTD" -dc "$a" | (cd "$staging" && "$ADM_TAR" -xpf -) || die "staging extract failed"
      ;;
    *.tar.xz)
      need_cmd "$ADM_XZ"
      "$ADM_XZ" -dc "$a" | (cd "$staging" && "$ADM_TAR" -xpf -) || die "staging extract failed"
      ;;
    *) die "unknown artifact type: $a" ;;
  esac

  oldmf="$(db_manifest)"
  oldmf_tmp=""
  if is_installed; then
    oldmf_tmp="$ADM_BUILD_DIR/.oldmf-$PKGNAME-$$"
    [ -f "$oldmf" ] && "$ADM_CP" -f "$oldmf" "$oldmf_tmp" || true
  fi

  log "install: applying to root $ADM_ROOT"
  (cd "$staging" && "$ADM_TAR" -cf - .) | (cd "$ADM_ROOT" && "$ADM_TAR" -xpf -) || die "apply failed"

  ensure_dir "$(db_pkg_dir)"
  (cd "$staging" && "$ADM_FIND" . -mindepth 1 -print | "$ADM_SED" 's#^\./##') | "$ADM_SORT" >"$ADM_BUILD_DIR/.newmf-$PKGNAME-$$"
  mv "$ADM_BUILD_DIR/.newmf-$PKGNAME-$$" "$(db_manifest)" || die "cannot commit manifest"
  "$ADM_TOUCH" "$(db_installed_marker)"
  write_meta

  if [ -n "$oldmf_tmp" ] && [ -f "$oldmf_tmp" ]; then
    log "upgrade: removing old files not present in new manifest"
    "$ADM_GREP" -vxFf "$(db_manifest)" "$oldmf_tmp" >"$ADM_BUILD_DIR/.remove-$PKGNAME-$$" || true
    remove_paths_from_manifest "$ADM_BUILD_DIR/.remove-$PKGNAME-$$"
    "$ADM_RM" -f "$ADM_BUILD_DIR/.remove-$PKGNAME-$$" "$oldmf_tmp" || true
  fi

  "$ADM_RM" -rf "$staging" || true
  log "installed: $(pkg_id)"
}

uninstall_pkg() {
  n="$1"
  mf="$ADM_DB_DIR/pkgs/$n/manifest"
  [ -f "$mf" ] || die "not installed: $n"
  log "uninstall: $n"
  remove_paths_from_manifest "$mf"
  "$ADM_RM" -rf "$ADM_DB_DIR/pkgs/$n" || true
  log "uninstalled: $n"
}

###############################################################################
# Build driver (fetch/unpack/prepare/build/check/install/package)
###############################################################################
build_pkg() {
  load_build_script "$1"
  log_init

  ADM_CURRENT_LOG="$(log_file_for "$PKGNAME" "$PKGVER" "$PKGREL")"
  export ADM_CURRENT_LOG

  log "build start: $(pkg_id) (section=$SECTION)"
  prepare_workdir

  st="$(state_get)"
  if [ "${ADM_RESUME:-1}" -eq 0 ]; then st="none"; fi

  # Run remaining phases based on state (resume)
  case "$st" in
    none)
      state_set "fetch";   call_phase "fetch"
      state_set "unpack";  call_phase "unpack"
      state_set "prepare"; call_phase "prepare"
      state_set "build";   call_phase "build"
      state_set "check";   call_phase "check"
      state_set "install"; call_phase "install"
      state_set "package"; pack_destdir
      state_set "done"
      ;;
    fetch)
      call_phase "fetch"
      state_set "unpack";  call_phase "unpack"
      state_set "prepare"; call_phase "prepare"
      state_set "build";   call_phase "build"
      state_set "check";   call_phase "check"
      state_set "install"; call_phase "install"
      state_set "package"; pack_destdir
      state_set "done"
      ;;
    unpack)
      call_phase "unpack"
      state_set "prepare"; call_phase "prepare"
      state_set "build";   call_phase "build"
      state_set "check";   call_phase "check"
      state_set "install"; call_phase "install"
      state_set "package"; pack_destdir
      state_set "done"
      ;;
    prepare)
      call_phase "prepare"
      state_set "build";   call_phase "build"
      state_set "check";   call_phase "check"
      state_set "install"; call_phase "install"
      state_set "package"; pack_destdir
      state_set "done"
      ;;
    build)
      call_phase "build"
      state_set "check";   call_phase "check"
      state_set "install"; call_phase "install"
      state_set "package"; pack_destdir
      state_set "done"
      ;;
    check)
      call_phase "check"
      state_set "install"; call_phase "install"
      state_set "package"; pack_destdir
      state_set "done"
      ;;
    install)
      call_phase "install"
      state_set "package"; pack_destdir
      state_set "done"
      ;;
    package)
      pack_destdir
      state_set "done"
      ;;
    done)
      log "build already done: $(pkg_id)"
      ;;
    *)
      # unknown state: restart
      state_set "fetch"; call_phase "fetch"
      state_set "unpack"; call_phase "unpack"
      state_set "prepare"; call_phase "prepare"
      state_set "build"; call_phase "build"
      state_set "check"; call_phase "check"
      state_set "install"; call_phase "install"
      state_set "package"; pack_destdir
      state_set "done"
      ;;
  esac

  log "build done: $(pkg_id)"
}

###############################################################################
# High-level operations
###############################################################################
install_with_deps() {
  target="$1"
  pd="$(pkg_path_from_name "$target")" || die "package not found: $target"
  load_build_script "$pd"

  ensure_dir "$ADM_BUILD_DIR"
  WORKDIR="$ADM_BUILD_DIR/.op-$$"
  ensure_dir "$WORKDIR"
  export WORKDIR

  req="$WORKDIR/.req"
  printf '%s\n' "$PKGNAME" >"$req"

  order="$(toposort "$req")" || die "dependency resolution failed"
  printf '%s\n' "$order" | while IFS= read -r p; do
    pdir="$(pkg_path_from_name "$p")" || die "missing build script for dependency: $p"
    load_build_script "$pdir"
    if is_installed; then
      log "dep already installed: $p"
    else
      log "installing dep: $p"
      install_pkg_loaded
    fi
  done

  "$ADM_RM" -rf "$WORKDIR" 2>/dev/null || true
}

info_pkg() {
  target="$1"
  pd="$(pkg_path_from_name "$target" 2>/dev/null || true)"
  if [ -n "$pd" ]; then
    load_build_script "$pd"
    if is_installed; then mark="[ ✔ ]"; else mark="[   ]"; fi
    echo "$mark $PKGNAME"
    echo "  Version: $PKGVER-r$PKGREL"
    echo "  Section: $SECTION"
    echo "  Desc:    ${PKGDESC:-}"
    echo "  URL:     ${PKGURL:-}"
    echo "  License: ${LICENSE:-}"
    echo "  Arch:    ${ARCH:-}"
    echo "  Depends: $(printf '%s' "$DEPENDS" | "$ADM_SED" 's/[[:space:]]\+/ /g; s/^ *//; s/ *$//')"
    echo "  BDepends: $(printf '%s' "$BUILD_DEPENDS" | "$ADM_SED" 's/[[:space:]]\+/ /g; s/^ *//; s/ *$//')"
    echo "  Hints:   $(printf '%s' "$AUTOBUILD_HINT" | "$ADM_SED" 's/[[:space:]]\+/ /g; s/^ *//; s/ *$//')"
  else
    d="$ADM_DB_DIR/pkgs/$target/meta"
    if [ -f "$d" ]; then
      echo "[ ✔ ] $target (installed; build script missing)"
      "$ADM_SED" 's/^/  /' "$d"
    else
      die "package not found: $target"
    fi
  fi
}

search_pkgs() {
  pat="$1"
  [ -n "$pat" ] || pat="."
  "$ADM_FIND" "$ADM_PKGS_DIR" -mindepth 2 -maxdepth 2 -type f -name build 2>/dev/null | while IFS= read -r b; do
    d=$(dirname "$b")
    c=$(basename "$(dirname "$d")")
    n=$(basename "$d")
    case "$n" in *"$pat"*) ;; *) continue ;; esac
    p="$c/$n"
    if [ -f "$ADM_DB_DIR/pkgs/$n/installed" ]; then
      echo "[ ✔ ] $p"
    else
      echo "[   ] $p"
    fi
  done | "$ADM_SORT"
}

list_installed() {
  "$ADM_FIND" "$ADM_DB_DIR/pkgs" -mindepth 2 -maxdepth 2 -type f -name installed 2>/dev/null | while IFS= read -r f; do
    n=$(basename "$(dirname "$f")")
    echo "[ ✔ ] $n"
  done | "$ADM_SORT"
}

sync_git() {
  [ -d "$ADM_GIT_REPO_DIR/.git" ] || die "not a git repo: $ADM_GIT_REPO_DIR"
  need_cmd "$ADM_GIT"
  (cd "$ADM_GIT_REPO_DIR" && \
    "$ADM_GIT" add -A && \
    "$ADM_GIT" status --porcelain | "$ADM_GREP" -q . || { msg "nothing to commit"; exit 0; } && \
    "$ADM_GIT" commit -m "adm-pkg sync $(now)" && \
    "$ADM_GIT" push) || die "git sync failed"
  msg "git sync complete"
}

clean_system() {
  log_init
  msg "clean: removing leftover build dirs older than 7 days (best-effort)"
  "$ADM_FIND" "$ADM_BUILD_DIR" -mindepth 1 -maxdepth 1 -type d -mtime +7 2>/dev/null | while IFS= read -r d; do
    "$ADM_RM" -rf "$d" 2>/dev/null || true
  done
  msg "clean: done"
}

rebuild_pkg() {
  target="$1"
  pd="$(pkg_path_from_name "$target")" || die "package not found: $target"
  load_build_script "$pd"
  w="$ADM_BUILD_DIR/$PKGNAME-$PKGVER-r$PKGREL"
  [ -d "$w" ] && "$ADM_RM" -rf "$w" || true
  build_pkg "$pd"
  install_pkg_loaded
}

###############################################################################
# CLI
###############################################################################
usage() {
  cat <<EOF
adm-pkg (POSIX sh) - rolling package manager

Usage:
  adm-pkg search <pattern>
  adm-pkg info <pkg|category/pkg>
  adm-pkg list
  adm-pkg install <pkg|category/pkg>
  adm-pkg uninstall <pkg>
  adm-pkg rebuild <pkg|category/pkg>
  adm-pkg clean
  adm-pkg sync

Build scripts:
  $ADM_PKGS_DIR/<category>/<pkg>/build

Patches:
  $ADM_PKGS_DIR/<category>/<pkg>/patch/*  (auto applied; patchlevel via PATCHLEVEL or AUTOBUILD_HINT patchlevel:)

Files overlay:
  $ADM_PKGS_DIR/<category>/<pkg>/files/*  (copied into DESTDIR; preserves modes if tar supports -p)

Hints (AUTOBUILD_HINT tokens, whitespace-separated):
  system:<name>              Force build system (cargo/go/python/npm/perl/ruby/scons/waf/meson/cmake/autotools/make)
  srcdir:<path>              Source directory relative to srcroot after unpack
  unpack:a.tar.xz,b.tar.xz   Choose archives to unpack (from staged WORKDIR filenames)
  patchlevel:<0..4>          Patch -p level for auto patch application
  cargo-bin:<name>           Install only that Rust binary
  go-bin:<name>              Name of Go binary when not using cmd/
  npm-build:<script>         Run npm run <script>
  npm-out:<dir>              Install output directory (default dist) to /usr/share/<pkg>
  npm-bin:<name>:<entry>     Create wrapper /usr/bin/<name> to run node /usr/share/<pkg>/<entry>
  waf-subdir:<path>          Build in subdir for waf

Resume:
  ADM_RESUME=1 (default) continues from last state on failure.
  ADM_RESUME=0 always starts from clean WORKDIR.

EOF
}

main() {
  log_init
  cmd="${1:-}"
  case "$cmd" in
    search) shift; search_pkgs "${1:-.}" ;;
    info) shift; [ -n "${1:-}" ] || die "info requires package"; info_pkg "$1" ;;
    list) list_installed ;;
    install) shift; [ -n "${1:-}" ] || die "install requires package"; with_lock; install_with_deps "$1"; unlock ;;
    uninstall) shift; [ -n "${1:-}" ] || die "uninstall requires package"; with_lock; uninstall_pkg "$1"; unlock ;;
    rebuild) shift; [ -n "${1:-}" ] || die "rebuild requires package"; with_lock; rebuild_pkg "$1"; unlock ;;
    clean) with_lock; clean_system; unlock ;;
    sync) with_lock; sync_git; unlock ;;
    help|-h|--help|"") usage ;;
    *) die "unknown command: $cmd (use: adm-pkg help)" ;;
  esac
}

main "$@"
