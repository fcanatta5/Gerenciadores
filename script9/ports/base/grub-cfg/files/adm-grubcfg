#!/bin/sh
set -eu

# adm-grubcfg: gera /boot/grub/grub.cfg de forma simples e robusta (UEFI/BIOS indiferente)
# Estratégia:
# - Detecta root por LABEL (ADMROOT) se existir; senão por UUID do /
# - Descobre kernel(s) /boot/vmlinuz-*
# - Descobre initramfs correspondente (initramfs-<ver>.img|initrd-<ver>.img|initramfs.img)
# - Inclui os-prober se disponível (opcional)
#
# Uso:
#   adm-grubcfg --update
#   adm-grubcfg --print-root
#   adm-grubcfg --set-root LABEL=ADMROOT|UUID=...

HDR="/usr/share/adm/grub.cfg.header"
OUT="/boot/grub/grub.cfg"
DEF="/etc/default/grub"

die(){ printf '%s\n' "adm-grubcfg: erro: $*" >&2; exit 1; }
msg(){ printf '%s\n' "adm-grubcfg: $*" >&2; }

have(){ command -v "$1" >/dev/null 2>&1; }

load_defaults() {
  GRUB_TIMEOUT=5
  GRUB_DEFAULT=0
  GRUB_DISABLE_OS_PROBER=false
  GRUB_CMDLINE_LINUX_DEFAULT=""

  [ -f "$DEF" ] && . "$DEF" || true
}

detect_root_spec() {
  # prefer LABEL=ADMROOT se existir
  if have blkid; then
    if blkid -L ADMROOT >/dev/null 2>&1; then
      echo "LABEL=ADMROOT"
      return 0
    fi
  fi

  # fallback: UUID do /
  if have findmnt && have blkid; then
    dev="$(findmnt -n -o SOURCE / 2>/dev/null || true)"
    [ -n "${dev:-}" ] || die "não consegui detectar device da root (/)"
    uuid="$(blkid -s UUID -o value "$dev" 2>/dev/null || true)"
    [ -n "${uuid:-}" ] || die "não consegui detectar UUID da root ($dev)"
    echo "UUID=$uuid"
    return 0
  fi

  die "não consegui detectar root (precisa de blkid + findmnt ou label ADMROOT)"
}

pick_kernel_list() {
  # lista vmlinuz-* em ordem (mais novo primeiro quando possível)
  if ls /boot/vmlinuz-* >/dev/null 2>&1; then
    ls -1 /boot/vmlinuz-* | sort -Vr 2>/dev/null || ls -1 /boot/vmlinuz-*
  else
    die "nenhum kernel encontrado em /boot (esperado /boot/vmlinuz-*)"
  fi
}

find_initrd_for_kernel() {
  kpath="$1"
  kbase="$(basename "$kpath")"
  ver="${kbase#vmlinuz-}"

  for cand in \
    "/boot/initramfs-${ver}.img" \
    "/boot/initrd-${ver}.img" \
    "/boot/initramfs-${ver}.gz" \
    "/boot/initrd-${ver}.gz" \
    "/boot/initramfs.img" \
    "/boot/initrd.img"
  do
    [ -f "$cand" ] && { echo "$cand"; return 0; }
  done

  echo ""
}

backup_out() {
  [ -f "$OUT" ] || return 0
  ts="$(date +%Y%m%d-%H%M%S 2>/dev/null || echo now)"
  cp -f "$OUT" "${OUT}.bak.${ts}" || true
}

write_header() {
  if [ -f "$HDR" ]; then
    cat "$HDR"
  else
    # header fallback (mínimo)
    cat <<'EOF'
set default=0
set timeout=5

insmod part_gpt
insmod fat
insmod ext2
insmod gzio
EOF
  fi
}

emit_menuentry() {
  title="$1"
  root_spec="$2"
  kpath="$3"
  initrd="$4"
  extra="$5"

  echo ""
  echo "menuentry \"$title\" {"
  echo "  search --no-floppy --set=root --file $(printf '%s' "$kpath")"
  # Para setups com /boot separado, acima resolve. Se /boot não é separado, GRUB ainda encontra o arquivo.

  echo "  linux $kpath root=$root_spec rw ${extra}"
  if [ -n "$initrd" ]; then
    echo "  initrd $initrd"
  fi
  echo "}"
}

gen_cfg() {
  load_defaults

  root_spec="$(detect_root_spec)"
  extra="${GRUB_CMDLINE_LINUX_DEFAULT:-}"

  tmp="$(mktemp)"
  {
    write_header
    echo ""
    echo "# generated by adm-grubcfg"
    echo "set default=${GRUB_DEFAULT}"
    echo "set timeout=${GRUB_TIMEOUT}"

    first=1
    for k in $(pick_kernel_list); do
      initrd="$(find_initrd_for_kernel "$k")"
      ver="$(basename "$k" | sed 's/^vmlinuz-//')"
      title="ADM Linux (musl) ${ver}"
      emit_menuentry "$title" "$root_spec" "$k" "$initrd" "$extra"
      first=0
    done

    if [ "${GRUB_DISABLE_OS_PROBER:-false}" != "true" ] && have os-prober && have grub-mkconfig; then
      echo ""
      echo "# os-prober integration (if grub-mkconfig is used separately)"
      echo "# Note: this file is generated directly; for full os-prober menus use grub-mkconfig."
    fi
  } >"$tmp"

  backup_out
  install -Dm644 "$tmp" "$OUT"
  rm -f "$tmp"
  msg "grub.cfg atualizado em $OUT (root=$root_spec)"
}

case "${1:-}" in
  --update) gen_cfg ;;
  --print-root) detect_root_spec ;;
  --set-root)
    die "--set-root não implementado (use LABEL=ADMROOT ou ajuste /etc/default/grub e regen)"
    ;;
  *)
    cat >&2 <<EOF
uso:
  adm-grubcfg --update
  adm-grubcfg --print-root
EOF
    exit 2
    ;;
esac
