#!/bin/sh
# adm — POSIX shell package builder/installer (repo local) com cache, deps, hooks, logs e upgrade atômico.
#
# Layout do repositório (exato):
#   /var/src/adm/packages/<categoria>/<programa>/
#     build         (script POSIX: apenas compila/instala em $DESTDIR; o adm faz o resto)
#     version       (versão em uma linha)
#     checksums     (linhas: "<hash>  <arquivo>" ; sha256=64hex ou md5=32hex)
#     depends       (um nome de programa por linha; somente nome)
#     sources       (um URL por linha; suporta http/https/ftp/git/ssh/git@... e múltiplos)
#     patch/        (opcional; *.patch/*.diff aplicados em ordem lexical)
#     files/        (opcional; tudo aqui é copiado para $DESTDIR antes de empacotar)
#     hooks/        (opcional; scripts executáveis):
#       pre-source post-source pre-extract pre-build post-build pre-install post-install post-package
#       pre-update post-update pre-remove post-remove
#     queue-status  (opcional; se executável, roda com PKG_EVENT=<evento>)
#
# O adm faz:
#   - download paralelo com barra/%, cache de sources e re-download se checksum falhar
#   - verificação de sha256/md5
#   - extração, aplicação de patch/, execução de hooks e queue-status
#   - build out-of-tree com env pronto (SRCROOT/BUILD_DIR/DESTDIR)
#   - overlay files/ no DESTDIR
#   - empacote tar.xz (xz -9e, -T0), cache de binários
#   - registro (manifest/meta/depends) e logs
#   - resolução de dependências (DFS topo + detecção de ciclo)
#   - install/upgrade: instala novo, só depois remove delta do antigo (com checagem de ownership)
#   - remove inteligente com hooks e preservação de arquivos compartilhados
#   - remoção de órfãos (auto=1) eficiente
#   - update via git pull do repo
#   - rebuild-all dos instalados
#   - search/info com [ ✔️ ] se instalado
#   - dry-run para tudo
#
# Uso:
#   adm help
#   adm index
#   adm search|s <texto>
#   adm info|in <programa>
#   adm download|d <programa>
#   adm build|b <programa>
#   adm install|i <programa>
#   adm remove|r <programa>
#   adm orphans|orph
#   adm update|u
#   adm rebuild-all|ra
#
# Flags globais:
#   -n, --dry-run
#   -S, --skip-checksums
#   -f, --force
#   --no-color
#   -j N
#
set -eu

###############################################################################
# Config
###############################################################################
ADM_ROOT="${ADM_ROOT:-/var/src/adm}"
REPO_DIR="${REPO_DIR:-$ADM_ROOT/packages}"

WORK_DIR="${WORK_DIR:-/var/tmp/adm/work}"
SRC_CACHE="${SRC_CACHE:-/var/cache/adm/sources}"
BIN_CACHE="${BIN_CACHE:-/var/cache/adm/bins}"

DB_DIR="${DB_DIR:-/var/lib/adm}"
INST_DIR="$DB_DIR/installed"
INDEX_CACHE="$DB_DIR/index.tsv"

LOG_DIR="${LOG_DIR:-/var/log/adm}"
STATE_DIR="$DB_DIR/state"

PREFIX="${PREFIX:-/usr/local}"
UMASK="${UMASK:-022}"

DRYRUN=0
SKIP_SUMS=0
FORCE=0
NO_COLOR=0
JOBS="${JOBS:-4}"

umask "$UMASK"

###############################################################################
# UI
###############################################################################
if [ -t 1 ] && [ "$NO_COLOR" -eq 0 ]; then
  C_RESET="$(printf '\033[0m')"
  C_BOLD="$(printf '\033[1m')"
  C_DIM="$(printf '\033[2m')"
  C_RED="$(printf '\033[31m')"
  C_GRN="$(printf '\033[32m')"
  C_YEL="$(printf '\033[33m')"
  C_CYN="$(printf '\033[36m')"
else
  C_RESET=""; C_BOLD=""; C_DIM=""; C_RED=""; C_GRN=""; C_YEL=""; C_CYN=""
fi

say()  { printf '%s\n' "$*"; }
info() { say "${C_CYN}[INFO]${C_RESET} $*"; }
ok()   { say "${C_GRN}[OK]${C_RESET}   $*"; }
warn() { say "${C_YEL}[WARN]${C_RESET} $*"; }
err()  { say "${C_RED}[ERRO]${C_RESET} $*" 1>&2; }
die()  { err "$*"; exit 1; }

run() {
  if [ "$DRYRUN" -eq 1 ]; then
    say "${C_DIM}DRY-RUN:${C_RESET} $*"
    return 0
  fi
  # shellcheck disable=SC2086
  sh -c "$*"
}

need_cmd() { command -v "$1" >/dev/null 2>&1 || die "Comando ausente: $1"; }
require_root() { [ "$(id -u)" -eq 0 ] || die "Este comando precisa de root."; }

ensure_dirs() {
  run "mkdir -p '$WORK_DIR' '$SRC_CACHE' '$BIN_CACHE' '$INST_DIR' '$LOG_DIR' '$STATE_DIR' '$DB_DIR'"
}

ts() { date '+%Y-%m-%d %H:%M:%S'; }

log_path_for() { printf '%s/%s-%s.log\n' "$LOG_DIR" "$1" "$(date '+%Y%m%d-%H%M%S')"; }

sanitize_name() { printf '%s' "$1" | sed 's/[^A-Za-z0-9._+-]/_/g'; }

###############################################################################
# Installed DB
###############################################################################
is_installed() { [ -d "$INST_DIR/$1" ]; }

installed_version() {
  [ -f "$INST_DIR/$1/meta" ] || return 1
  awk -F= '$1=="version"{print $2; exit}' "$INST_DIR/$1/meta"
}

installed_auto() {
  [ -f "$INST_DIR/$1/meta" ] || return 1
  awk -F= '$1=="auto"{print $2; exit}' "$INST_DIR/$1/meta"
}

###############################################################################
# Repo index
###############################################################################
build_index() {
  ensure_dirs
  info "Indexando: ${C_BOLD}$REPO_DIR${C_RESET}"
  tmp="$STATE_DIR/index.$$.tmp"
  if [ "$DRYRUN" -eq 0 ]; then
    find "$REPO_DIR" -mindepth 2 -maxdepth 2 -type d 2>/dev/null \
      | while IFS= read -r d; do
          n="$(basename "$d")"
          c="$(basename "$(dirname "$d")")"
          printf '%s\t%s\t%s\n' "$n" "$c" "$d"
        done | sort -u >"$tmp"
    mv "$tmp" "$INDEX_CACHE"
  else
    say "${C_DIM}DRY-RUN:${C_RESET} find '$REPO_DIR' ... > '$INDEX_CACHE'"
  fi
  ok "Index pronto: $INDEX_CACHE"
}

resolve_pkg_path() {
  [ -f "$INDEX_CACHE" ] || build_index
  awk -F'\t' -v p="$1" '$1==p{print $3}' "$INDEX_CACHE" | head -n 1
}

resolve_pkg_cat() {
  [ -f "$INDEX_CACHE" ] || build_index
  awk -F'\t' -v p="$1" '$1==p{print $2}' "$INDEX_CACHE" | head -n 1
}

resolve_pkg_ambiguous() {
  # se houver múltiplas categorias com mesmo nome, retorna >1 linhas
  [ -f "$INDEX_CACHE" ] || build_index
  awk -F'\t' -v p="$1" '$1==p{print $2 "\t" $3}' "$INDEX_CACHE"
}

###############################################################################
# Recipe I/O
###############################################################################
read_version() {
  [ -f "$1/version" ] || die "version ausente: $1"
  sed -n '1p' "$1/version" | tr -d '\r\n'
}

list_depends() {
  if [ -f "$1/depends" ]; then
    sed 's/#.*$//' "$1/depends" | awk 'NF{print $1}'
  fi
}

list_sources() {
  if [ -f "$1/sources" ]; then
    sed 's/#.*$//' "$1/sources" | awk 'NF{print $0}'
  fi
}

checksum_kind() {
  # Detecta por tamanho do hash (primeira linha)
  [ -f "$1" ] || { echo ""; return 0; }
  h="$(awk 'NF{print $1; exit}' "$1" | tr -d '\r')"
  case "${#h}" in
    64) echo "sha256" ;;
    32) echo "md5" ;;
    *)  echo "" ;;
  esac
}

sum_cmd_for() {
  case "$1" in
    sha256) command -v sha256sum >/dev/null 2>&1 && echo "sha256sum" || echo "" ;;
    md5)    command -v md5sum    >/dev/null 2>&1 && echo "md5sum"    || echo "" ;;
    *)      echo "" ;;
  esac
}

verify_checksums_dir() {
  # $1=dir $2=checksumsfile (formato: "<hash>  <file>")
  [ "$SKIP_SUMS" -eq 1 ] && { warn "Checksums: SKIP"; return 0; }
  [ -f "$2" ] || { warn "checksums ausente; pulando verificação."; return 0; }

  kind="$(checksum_kind "$2")"
  [ -n "$kind" ] || die "checksums inválido (hash desconhecido): $2"

  cmd="$(sum_cmd_for "$kind")"
  [ -n "$cmd" ] || die "Faltando ferramenta para $kind (precisa de ${kind}sum)."

  (cd "$1" && "$cmd" -c "$2") >/dev/null 2>&1
}

###############################################################################
# Hooks + queue-status
###############################################################################
run_queue_status() {
  # $1=pkgpath $2=event
  qs="$1/queue-status"
  if [ -f "$qs" ] && [ -x "$qs" ]; then
    info "queue-status: ${C_BOLD}$2${C_RESET}"
    run "PKG_EVENT='$2' '$qs'"
  fi
}

run_hook() {
  # $1=pkgpath $2=hookname
  h="$1/hooks/$2"
  if [ -f "$h" ] && [ -x "$h" ]; then
    info "hook: ${C_BOLD}$2${C_RESET}"
    run "PKG_HOOK='$2' '$h'"
  fi
}

###############################################################################
# Download tooling
###############################################################################
dl_tool() {
  if command -v curl >/dev/null 2>&1; then echo "curl"
  elif command -v wget >/dev/null 2>&1; then echo "wget"
  else echo ""
  fi
}

download_http_one() {
  # $1=url $2=outfile
  tool="$(dl_tool)"
  [ -n "$tool" ] || die "Precisa de curl ou wget."
  if [ "$tool" = "curl" ]; then
    run "curl -L --fail --retry 3 --retry-delay 1 --progress-bar -o '$2' '$1'"
  else
    run "wget --tries=3 --timeout=30 --progress=bar:force:noscroll -O '$2' '$1'"
  fi
}

hash_key() {
  # hash estável para URL (sha256 se possível, senão md5)
  if command -v sha256sum >/dev/null 2>&1; then
    printf '%s' "$1" | sha256sum | awk '{print $1}'
  else
    printf '%s' "$1" | md5sum | awk '{print $1}'
  fi
}

url_basename() {
  printf '%s' "$1" | sed 's/[?#].*$//' | awk -F/ '{print $NF}'
}

download_git_cached() {
  # $1=url $2=cachedir
  need_cmd git
  k="$(hash_key "$1")"
  d="$2/git-$k"
  if [ -d "$d/.git" ]; then
    info "git cache hit: ${C_BOLD}$1${C_RESET}"
    run "git -C '$d' fetch --all --prune"
    # mantém estado local consistente; origin/HEAD pode não existir em todos os remotos
    run "git -C '$d' reset --hard HEAD"
  else
    info "git clone: ${C_BOLD}$1${C_RESET}"
    run "rm -rf '$d'"
    run "git clone --recursive '$1' '$d'"
  fi
  echo "$d"
}

copy_cached_or_download_one() {
  # $1=url $2=pkgpath $3=outdir
  url="$1"; pkgpath="$2"; outdir="$3"
  checks="$pkgpath/checksums"
  mkdir -p "$outdir" "$SRC_CACHE"

  case "$url" in
    http://*|https://*|ftp://*)
      f="$(url_basename "$url")"
      [ -n "$f" ] || die "URL inválida: $url"
      cf="$SRC_CACHE/$f"
      of="$outdir/$f"

      if [ -f "$cf" ]; then
        info "cache source: $f"
        run "cp -f '$cf' '$of'"
        if verify_checksums_dir "$outdir" "$checks"; then
          ok "checksum OK (cache): $f"
          return 0
        fi
        warn "checksum falhou (cache): $f; rebaixando"
        run "rm -f '$cf' '$of'"
      fi

      info "download: ${C_BOLD}$f${C_RESET}"
      download_http_one "$url" "$of"

      if verify_checksums_dir "$outdir" "$checks"; then
        ok "checksum OK: $f"
        run "cp -f '$of' '$cf'"
      else
        run "rm -f '$of' '$cf'"
        die "checksum falhou após download: $f"
      fi
      ;;
    git:*|ssh://*|git@*:*|*".git"|git+*)
      d="$(download_git_cached "$url" "$SRC_CACHE")"
      k="$(basename "$d")"
      run "rm -rf '$outdir/$k'"
      run "cp -a '$d' '$outdir/$k'"
      ;;
    *)
      die "source não suportada: $url"
      ;;
  esac
}

# Paralelo via xargs -P chamando subcomando interno "__dl_one"
download_sources_parallel() {
  # $1=pkgpath $2=outdir
  pkgpath="$1"; outdir="$2"
  srcs="$(list_sources "$pkgpath" || true)"
  [ -n "${srcs:-}" ] || { info "Sem sources."; return 0; }

  listfile="$STATE_DIR/sources.$$.list"
  if [ "$DRYRUN" -eq 0 ]; then
    printf '%s\n' "$srcs" >"$listfile"
    xargs -r -P "$JOBS" -n 1 sh -c '
      set -eu
      me="$1"; url="$2"; pkgpath="$3"; outdir="$4"
      exec "$me" __dl_one "$url" "$pkgpath" "$outdir"
    ' sh "$0" {} "$pkgpath" "$outdir" <"$listfile"
    rm -f "$listfile"
  else
    say "${C_DIM}DRY-RUN:${C_RESET} downloads paralelos:"
    printf '%s\n' "$srcs" | sed 's/^/  - /'
  fi
}

###############################################################################
# Deps: topo + ciclo
###############################################################################
deps_toposort() {
  # $1=pkgname -> imprime ordem com deps primeiro (inclui o próprio)
  ensure_dirs
  marks="$STATE_DIR/marks.$$.tmp"
  out="$STATE_DIR/order.$$.tmp"
  : >"$marks"
  : >"$out"

  dfs() {
    n="$1"
    if grep -q "^perm $n\$" "$marks"; then return 0; fi
    if grep -q "^temp $n\$" "$marks"; then die "Ciclo em dependências envolvendo: $n"; fi
    echo "temp $n" >>"$marks"

    p="$(resolve_pkg_path "$n")"
    [ -n "$p" ] || die "Dependência não encontrada no repo: $n"
    for d in $(list_depends "$p"); do
      dfs "$d"
    done

    # remove temp mark
    grep -v "^temp $n\$" "$marks" >"$marks.$$" && mv "$marks.$$" "$marks"
    echo "perm $n" >>"$marks"
    echo "$n" >>"$out"
  }

  dfs "$1"
  cat "$out"
  rm -f "$marks" "$out"
}

###############################################################################
# Extract + patch + files overlay
###############################################################################
extract_sources() {
  # $1=dl_dir $2=src_dir
  dld="$1"; srcd="$2"
  run "mkdir -p '$srcd'"
  # Prefer git snapshot se houver
  g="$(find "$dld" -maxdepth 1 -type d -name 'git-*' | head -n 1 || true)"
  if [ -n "$g" ]; then
    info "extract: git snapshot"
    run "rm -rf '$srcd/src' && mkdir -p '$srcd'"
    run "cp -a '$g' '$srcd/src'"
    echo "$srcd/src"
    return 0
  fi

  # Primeiro tar.* encontrado
  t="$(find "$dld" -maxdepth 1 -type f \
    \( -name '*.tar' -o -name '*.tar.gz' -o -name '*.tgz' -o -name '*.tar.bz2' -o -name '*.tbz2' -o -name '*.tar.xz' -o -name '*.txz' \) \
    | head -n 1 || true)"
  [ -n "$t" ] || die "Nenhum tarball encontrado em $dld (sources inválidas?)"

  info "extract: $(basename "$t")"
  run "rm -rf '$srcd'/*"
  run "tar -xf '$t' -C '$srcd'"

  # SRCROOT: primeiro diretório de 1º nível
  if [ "$DRYRUN" -eq 0 ]; then
    r="$(find "$srcd" -mindepth 1 -maxdepth 1 -type d | head -n 1 || true)"
    [ -n "$r" ] || r="$srcd"
  else
    r="$srcd"
  fi
  echo "$r"
}

apply_patches_dir() {
  # $1=pkgpath $2=srcroot
  pkgpath="$1"; srcroot="$2"
  [ -d "$pkgpath/patch" ] || return 0
  command -v patch >/dev/null 2>&1 || { warn "patch ausente; ignorando patch/."; return 0; }

  found=0
  for p in "$pkgpath"/patch/*.patch "$pkgpath"/patch/*.diff; do
    [ -f "$p" ] || continue
    found=1
    info "patch: $(basename "$p")"
    run "patch -d '$srcroot' -p1 < '$p'"
  done
  [ "$found" -eq 1 ] || true
}

overlay_files_dir() {
  # $1=pkgpath $2=destdir
  [ -d "$1/files" ] || return 0
  # Só copia se houver conteúdo
  if [ "$DRYRUN" -eq 0 ]; then
    if find "$1/files" -mindepth 1 -maxdepth 1 >/dev/null 2>&1; then
      info "overlay: files/ -> DESTDIR"
      run "cp -a '$1/files/.' '$2/'"
    fi
  else
    say "${C_DIM}DRY-RUN:${C_RESET} overlay files/ -> DESTDIR"
  fi
}

###############################################################################
# Packaging
###############################################################################
pkg_filename() {
  # $1=pkg $2=ver
  arch="$(uname -m 2>/dev/null || echo unknown)"
  echo "$BIN_CACHE/$1-$2-$arch.tar.xz"
}

tar_supports_sort() { tar --help 2>/dev/null | grep -q -- '--sort'; }

package_destdir() {
  # $1=destdir $2=pkgfile $3=logfile
  dest="$1"; pf="$2"; lf="$3"
  info "package: ${C_BOLD}$(basename "$pf")${C_RESET}"
  if [ "$DRYRUN" -eq 0 ]; then
    if tar_supports_sort; then
      (cd "$dest" && tar --sort=name --mtime='UTC 2020-01-01' --owner=0 --group=0 --numeric-owner -cf - .) \
        | xz -T0 -9e >"$pf" 2>>"$lf"
    else
      (cd "$dest" && tar -cf - .) | xz -T0 -9e >"$pf" 2>>"$lf"
    fi
  else
    say "${C_DIM}DRY-RUN:${C_RESET} tar|xz -> '$pf'"
  fi
}

###############################################################################
# Ownership helpers (arquivos compartilhados)
###############################################################################
file_owned_by_other() {
  # $1=file(relativo, sem leading /) $2=thispkg
  f="$1"; self="$2"
  # procura em manifests dos instalados (exclui self)
  for d in "$INST_DIR"/*; do
    [ -d "$d" ] || continue
    p="$(basename "$d")"
    [ "$p" = "$self" ] && continue
    mf="$d/manifest"
    [ -f "$mf" ] || continue
    if grep -Fxq "$f" "$mf"; then
      return 0
    fi
  done
  return 1
}

###############################################################################
# Build (o build do pacote é "limpo": só compila/instala)
###############################################################################
build_one() {
  pkg="$1"

  # Ambiguidade
  amb="$(resolve_pkg_ambiguous "$pkg" | wc -l | awk '{print $1}')"
  if [ "$amb" -gt 1 ]; then
    err "Programa ambíguo (mesmo nome em múltiplas categorias): $pkg"
    resolve_pkg_ambiguous "$pkg" | awk '{printf "  - %s (%s)\n", $2, $1}'
    die "Renomeie ou mantenha nomes únicos por categoria."
  fi

  pkgpath="$(resolve_pkg_path "$pkg")"
  [ -n "$pkgpath" ] || die "Não encontrado no repo: $pkg"
  ver="$(read_version "$pkgpath")"
  catg="$(resolve_pkg_cat "$pkg")"

  pf="$(pkg_filename "$pkg" "$ver")"
  if [ -f "$pf" ] && [ "$FORCE" -eq 0 ]; then
    ok "bin cache hit: $pf"
    return 0
  fi

  ensure_dirs
  lf="$(log_path_for "$pkg")"
  info "build: ${C_BOLD}$pkg${C_RESET} ${C_DIM}($catg)${C_RESET} v${C_BOLD}$ver${C_RESET}"
  info "log:  ${C_BOLD}$lf${C_RESET}"

  b="$WORK_DIR/build/$(sanitize_name "$pkg")-$ver.$$"
  dld="$b/dl"
  srcd="$b/src"
  buildd="$b/build"
  dest="$b/dest"

  run "mkdir -p '$dld' '$srcd' '$buildd' '$dest'"

  export PKG="$pkg" VER="$ver" PKGPATH="$pkgpath"
  export WORK="$b" DL_DIR="$dld" SRC_DIR="$srcd" BUILD_DIR="$buildd" DESTDIR="$dest"
  export PREFIX="$PREFIX" JOBS="$JOBS" LOGFILE="$lf"

  {
    echo "== $(ts) :: build $pkg $ver =="
    echo "PKGPATH=$pkgpath"
    echo "WORK=$b"
    echo "PREFIX=$PREFIX"
    echo "JOBS=$JOBS"
  } >>"$lf"

  run_queue_status "$pkgpath" "pre-source"
  run_hook "$pkgpath" "pre-source"

  download_sources_parallel "$pkgpath" "$dld" >>"$lf" 2>&1

  run_hook "$pkgpath" "post-source"
  run_queue_status "$pkgpath" "post-source"

  run_hook "$pkgpath" "pre-extract"
  run_queue_status "$pkgpath" "pre-extract"

  srcroot="$(extract_sources "$dld" "$srcd")"
  export SRCROOT="$srcroot"

  apply_patches_dir "$pkgpath" "$SRCROOT" >>"$lf" 2>&1

  run_hook "$pkgpath" "pre-build"
  run_queue_status "$pkgpath" "pre-build"

  [ -f "$pkgpath/build" ] || die "build ausente: $pkgpath/build"
  info "run build script: ${C_BOLD}$pkgpath/build${C_RESET}"
  if [ "$DRYRUN" -eq 0 ]; then
    (
      set -eu
      cd "$SRCROOT" 2>/dev/null || true
      if [ -x "$pkgpath/build" ]; then
        "$pkgpath/build"
      else
        sh "$pkgpath/build"
      fi
    ) >>"$lf" 2>&1 || die "Build falhou. Veja: $lf"
  else
    say "${C_DIM}DRY-RUN:${C_RESET} executaria '$pkgpath/build'"
  fi

  run_hook "$pkgpath" "post-build"
  run_queue_status "$pkgpath" "post-build"

  run_hook "$pkgpath" "pre-install"
  run_queue_status "$pkgpath" "pre-install"

  overlay_files_dir "$pkgpath" "$DESTDIR" >>"$lf" 2>&1

  run_hook "$pkgpath" "post-install"
  run_queue_status "$pkgpath" "post-install"

  run_hook "$pkgpath" "post-package"
  run_queue_status "$pkgpath" "post-package"

  package_destdir "$DESTDIR" "$pf" "$lf"

  ok "build OK: ${C_BOLD}$pkg${C_RESET} v$ver"
  ok "bin: $pf"
}

###############################################################################
# Install / Upgrade / Remove
###############################################################################
record_installed_db() {
  # $1=pkg $2=ver $3=auto(0/1) $4=pkgpath
  pkg="$1"; ver="$2"; auto="$3"; pkgpath="$4"
  idir="$INST_DIR/$pkg"
  run "mkdir -p '$idir'"

  # meta
  if [ "$DRYRUN" -eq 0 ]; then
    {
      echo "name=$pkg"
      echo "version=$ver"
      echo "category=$(resolve_pkg_cat "$pkg" || echo unknown)"
      echo "auto=$auto"
      echo "installed_at=$(ts)"
    } >"$idir/meta"
  fi

  # depends snapshot (para reverse-deps/orphans mesmo se recipe sumir)
  if [ "$DRYRUN" -eq 0 ]; then
    if [ -f "$pkgpath/depends" ]; then
      sed 's/#.*$//' "$pkgpath/depends" | awk 'NF{print $1}' >"$idir/depends"
    else
      : >"$idir/depends"
    fi
  fi
}

manifest_from_tar() {
  # $1=tarfile -> stdout lista relativa sem leading ./
  tar -tf "$1" | sed 's|^\./||' | awk 'NF{print $0}' | sort -u
}

install_tar_root() {
  # $1=tarfile
  tf="$1"
  if [ "$DRYRUN" -eq 0 ]; then
    tar -xJf "$tf" -C / --no-same-owner --overwrite
  else
    say "${C_DIM}DRY-RUN:${C_RESET} tar -xJf '$tf' -C / --overwrite"
  fi
}

remove_files_from_manifest_delta() {
  # remove arquivos que estavam no old mas não estão no new
  # $1=pkg $2=oldmf $3=newmf
  pkg="$1"; oldmf="$2"; newmf="$3"

  if [ "$DRYRUN" -eq 1 ]; then
    say "${C_DIM}DRY-RUN:${C_RESET} removeria delta de arquivos obsoletos (seguro)"
    return 0
  fi

  # lista delta: old - new
  awk 'FNR==NR{n[$0]=1; next} !n[$0]{print $0}' "$newmf" "$oldmf" \
    | while IFS= read -r f; do
        [ -n "$f" ] || continue
        case "$f" in
          *".."* ) continue ;;
        esac
        # se outro pacote ainda possui, não remove
        if file_owned_by_other "$f" "$pkg"; then
          continue
        fi
        rm -f "/$f" 2>/dev/null || true
      done

  # remove dirs vazios (derivados do oldmf), com segurança
  awk -F/ 'NF>1{p=""; for(i=1;i<NF;i++){p=p"/"$i; print p}}' "$oldmf" \
    | sort -u -r | while IFS= read -r d; do
        [ -n "$d" ] || continue
        rmdir "/$d" 2>/dev/null || true
      done
}

install_one() {
  # $1=pkg $2=auto(0 manual / 1 auto)
  pkg="$1"; auto="${2:-0}"

  pkgpath="$(resolve_pkg_path "$pkg")"
  [ -n "$pkgpath" ] || die "Não encontrado no repo: $pkg"
  ver="$(read_version "$pkgpath")"
  pf="$(pkg_filename "$pkg" "$ver")"

  # deps (topo)
  info "deps: ${C_BOLD}$pkg${C_RESET}"
  for p in $(deps_toposort "$pkg"); do
    [ "$p" = "$pkg" ] && continue
    if ! is_installed "$p"; then
      install_one "$p" 1
    fi
  done

  # build se necessário
  if [ ! -f "$pf" ] || [ "$FORCE" -eq 1 ]; then
    build_one "$pkg"
  fi

  # hooks + queue-status
  run_queue_status "$pkgpath" "pre-install"
  run_hook "$pkgpath" "pre-install"

  oldver=""
  oldmf_tmp="$STATE_DIR/$pkg.oldmf.$$"
  newmf_tmp="$STATE_DIR/$pkg.newmf.$$"

  if is_installed "$pkg"; then
    oldver="$(installed_version "$pkg" || true)"
    if [ -f "$INST_DIR/$pkg/manifest" ] && [ "$DRYRUN" -eq 0 ]; then
      cp -f "$INST_DIR/$pkg/manifest" "$oldmf_tmp"
    fi
  fi

  info "install: ${C_BOLD}$pkg${C_RESET} v${C_BOLD}$ver${C_RESET}"
  install_tar_root "$pf"

  # novo manifest
  if [ "$DRYRUN" -eq 0 ]; then
    manifest_from_tar "$pf" >"$newmf_tmp"
  fi

  # grava DB (inclui manifest definitivo)
  if [ "$DRYRUN" -eq 0 ]; then
    idir="$INST_DIR/$pkg"
    mkdir -p "$idir"
    cp -f "$newmf_tmp" "$idir/manifest"
  fi
  record_installed_db "$pkg" "$ver" "$auto" "$pkgpath"

  run_hook "$pkgpath" "post-install"
  run_queue_status "$pkgpath" "post-install"

  # upgrade seguro: remove delta do antigo somente após sucesso e somente o que não pertence a outros pkgs
  if [ -n "$oldver" ] && [ "$oldver" != "$ver" ] && [ -f "$oldmf_tmp" ] && [ -f "$newmf_tmp" ]; then
    info "upgrade: removendo delta antigo (seguro) $pkg v$oldver -> v$ver"
    remove_files_from_manifest_delta "$pkg" "$oldmf_tmp" "$newmf_tmp"
  fi

  run "rm -f '$oldmf_tmp' '$newmf_tmp' 2>/dev/null || true"
  ok "instalado: $pkg v$ver"
}

remove_one() {
  pkg="$1"
  require_root
  is_installed "$pkg" || die "Não instalado: $pkg"

  pkgpath="$(resolve_pkg_path "$pkg" || true)"
  if [ -n "$pkgpath" ]; then
    run_queue_status "$pkgpath" "pre-remove"
    run_hook "$pkgpath" "pre-remove"
  fi

  mf="$INST_DIR/$pkg/manifest"
  [ -f "$mf" ] || die "manifest ausente (DB corrompido?): $mf"

  info "remove: ${C_BOLD}$pkg${C_RESET}"

  if [ "$DRYRUN" -eq 0 ]; then
    # remove arquivos do manifest, mas preserva se outro pacote possuir
    tac "$mf" 2>/dev/null | while IFS= read -r f; do
      [ -n "$f" ] || continue
      case "$f" in *".."*) continue ;; esac
      if file_owned_by_other "$f" "$pkg"; then
        continue
      fi
      rm -f "/$f" 2>/dev/null || true
    done

    # remove dirs vazios
    awk -F/ 'NF>1{p=""; for(i=1;i<NF;i++){p=p"/"$i; print p}}' "$mf" \
      | sort -u -r | while IFS= read -r d; do rmdir "/$d" 2>/dev/null || true; done

    rm -rf "$INST_DIR/$pkg"
  else
    say "${C_DIM}DRY-RUN:${C_RESET} removeria arquivos do manifest e apagaria DB de $pkg"
  fi

  if [ -n "$pkgpath" ]; then
    run_hook "$pkgpath" "post-remove" || true
    run_queue_status "$pkgpath" "post-remove" || true
  fi

  ok "removido: $pkg"
}

reverse_deps() {
  # $1=pkg -> lista instalados que dependem dele (usando snapshot depends do DB)
  target="$1"
  for d in "$INST_DIR"/*; do
    [ -d "$d" ] || continue
    p="$(basename "$d")"
    depf="$d/depends"
    [ -f "$depf" ] || continue
    if grep -Fxq "$target" "$depf"; then
      echo "$p"
    fi
  done | sort -u
}

remove_orphans() {
  require_root
  info "orphans: removendo auto=1 sem reverse-deps"
  changed=1
  while [ "$changed" -eq 1 ]; do
    changed=0
    for d in "$INST_DIR"/*; do
      [ -d "$d" ] || continue
      p="$(basename "$d")"
      a="$(installed_auto "$p" 2>/dev/null || echo 0)"
      [ "$a" = "1" ] || continue
      r="$(reverse_deps "$p" | wc -l | awk '{print $1}')"
      if [ "$r" -eq 0 ]; then
        warn "órfão: $p"
        remove_one "$p"
        changed=1
      fi
    done
  done
  ok "orphans: concluído"
}

###############################################################################
# Update / Rebuild-all
###############################################################################
repo_update() {
  ensure_dirs
  if [ -d "$ADM_ROOT/.git" ]; then
    need_cmd git
    info "update: git pull em ${C_BOLD}$ADM_ROOT${C_RESET}"
    run "git -C '$ADM_ROOT' pull --ff-only"
    ok "update: OK"
  else
    warn "update: $ADM_ROOT não é git; pulando"
  fi
  build_index
}

rebuild_all_installed() {
  require_root
  info "rebuild-all: reconstruindo e reinstalando todos os instalados"
  for d in "$INST_DIR"/*; do
    [ -d "$d" ] || continue
    p="$(basename "$d")"
    a="$(installed_auto "$p" 2>/dev/null || echo 0)"
    build_one "$p"
    install_one "$p" "$a"
  done
  ok "rebuild-all: OK"
}

###############################################################################
# Search / Info
###############################################################################
cmd_search() {
  pat="${1:-}"
  [ -n "$pat" ] || die "Uso: adm search <texto>"
  [ -f "$INDEX_CACHE" ] || build_index
  awk -F'\t' -v p="$pat" '
    BEGIN{IGNORECASE=1}
    $1~p || $2~p {print $1 "\t" $2}
  ' "$INDEX_CACHE" | while IFS="$(printf '\t')" read -r n c; do
    if is_installed "$n"; then
      printf '%s %s/%s\n' "[ ✔️]" "$c" "$n"
    else
      printf '%s %s/%s\n' "[   ]" "$c" "$n"
    fi
  done
}

cmd_info() {
  pkg="${1:-}"
  [ -n "$pkg" ] || die "Uso: adm info <programa>"
  p="$(resolve_pkg_path "$pkg")"
  [ -n "$p" ] || die "Não encontrado: $pkg"

  v="$(read_version "$p")"
  c="$(resolve_pkg_cat "$pkg")"

  say "${C_BOLD}$pkg${C_RESET}  ${C_DIM}${c}/${pkg}${C_RESET}"
  say "version(repo): $v"
  if is_installed "$pkg"; then
    iv="$(installed_version "$pkg" || true)"
    say "installed: [ ✔️ ] version=$iv"
  else
    say "installed: [   ]"
  fi

  if [ -f "$p/depends" ]; then
    say "depends:"
    list_depends "$p" | sed 's/^/  - /'
  else
    say "depends: (nenhum)"
  fi

  if [ -f "$p/sources" ]; then
    say "sources:"
    list_sources "$p" | sed 's/^/  - /'
  fi
}

cmd_download() {
  pkg="${1:-}"
  [ -n "$pkg" ] || die "Uso: adm download <programa>"
  pkgpath="$(resolve_pkg_path "$pkg")"
  [ -n "$pkgpath" ] || die "Não encontrado: $pkg"
  ensure_dirs
  dld="$WORK_DIR/download-only/$(sanitize_name "$pkg").$$"
  run "mkdir -p '$dld'"
  info "download: ${C_BOLD}$pkg${C_RESET}"
  download_sources_parallel "$pkgpath" "$dld"
  ok "downloads em: $dld"
}

###############################################################################
# CLI
###############################################################################
usage() {
  cat <<EOF
adm — builder/installer POSIX (repo local)

Comandos:
  adm help
  adm index
  adm search|s <texto>
  adm info|in <programa>
  adm download|d <programa>
  adm build|b <programa>
  adm install|i <programa>        (root)
  adm remove|r <programa>         (root)
  adm orphans|orph                (root)
  adm update|u
  adm rebuild-all|ra              (root)

Flags globais:
  -n, --dry-run
  -S, --skip-checksums
  -f, --force
  --no-color
  -j N  (downloads paralelos; padrão: $JOBS)

Env úteis:
  ADM_ROOT=$ADM_ROOT
  REPO_DIR=$REPO_DIR
  PREFIX=$PREFIX
  WORK_DIR=$WORK_DIR
  SRC_CACHE=$SRC_CACHE
  BIN_CACHE=$BIN_CACHE
  LOG_DIR=$LOG_DIR
EOF
}

parse_flags() {
  while [ $# -gt 0 ]; do
    case "$1" in
      -n|--dry-run) DRYRUN=1; shift ;;
      -S|--skip-checksums) SKIP_SUMS=1; shift ;;
      -f|--force) FORCE=1; shift ;;
      --no-color) NO_COLOR=1; shift ;;
      -j) shift; JOBS="${1:-4}"; shift ;;
      --) shift; break ;;
      *) break ;;
    esac
  done
  echo "$@"
}

main() {
  ensure_dirs
  need_cmd tar
  need_cmd xz
  need_cmd find
  need_cmd awk
  need_cmd sed
  need_cmd grep
  need_cmd sort

  # subcomando interno (para xargs -P)
  if [ "${1:-}" = "__dl_one" ]; then
    shift
    url="$1"; pkgpath="$2"; outdir="$3"
    copy_cached_or_download_one "$url" "$pkgpath" "$outdir"
    exit 0
  fi

  set -- $(parse_flags "$@")
  cmd="${1:-help}"; shift || true

  case "$cmd" in
    help|-h|--help) usage ;;
    index) build_index ;;
    search|s) cmd_search "${1:-}" ;;
    info|in) cmd_info "${1:-}" ;;
    download|d) cmd_download "${1:-}" ;;
    build|b) build_one "${1:-}" ;;
    install|i) require_root; install_one "${1:-}" 0 ;;
    remove|r) require_root; remove_one "${1:-}" ;;
    orphans|orph) require_root; remove_orphans ;;
    update|u) repo_update ;;
    rebuild-all|ra) require_root; rebuild_all_installed ;;
    *) die "Comando desconhecido: $cmd (use: adm help)" ;;
  esac
}

main "$@"
